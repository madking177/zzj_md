### 逆向日记系列



# 1.脱壳实战（工具篇） 

简述

通用脱壳工具好使，遇到反脱壳的检测手段稍微上点难度就jj了。

聊这么多基础原理，都是为了降维打击和多一些逆向思路。

比如fart ，cookie脱壳（此处 cookie为art内部术语，不是web cookie）

## 找包packagae

> dumpsys window windows | grep mCurrentFocus

```txt
adb shell dumpsys window windows | grep mCurrentFocus

mCurrentFocus=Window{e415d0f u0 com.chaoxing.mobile/com.chaoxing.mobile.main.ui.MainTabActivity}
```



<img src="./img/assets/image-20240413005807391.png" alt="image-20240413005807391" style="zoom:80%;" />





## frida-dexdump脱壳



```
核心原理：暴力搜索
git地址：https://github.com/hluwa/frida-dexdump?tab=readme-ov-file
公众号地址：https://mp.weixin.qq.com/s/n2XHGhshTmvt2FhxyFfoMA

frida-dexdump -U -n com.chaoxing.mobile -o ./xuexitong -d --sleep 5

-o 输出目录
-d 深度搜索
--sleep 等待？s开始脱壳

结果：扫描出来一堆没用的dex文件
```

### -n运行

![image-20240413015032525](./img/assets/image-20240413015032525.png)



```
显示all done说明结束

然后整体编译刚脱壳出来的文件
jadx -d <输出目录路径> *.dex
jadx -d output *.dex

如果hook时间不合适 如下图
```



![image-20240413015833031](./img/assets/image-20240413015833031.png)



### -f运行

![image-20240413015926153](./img/assets/image-20240413015926153.png)



### 反编译失败

![image-20240413020804232](./img/assets/image-20240413020804232.png)



## blackdex   32位，64位apk脱壳

blackdex地址 https://github.com/CodingGay/BlackDex/releases 



![image-20240413023142902](./img/assets/image-20240413023142902.png)

#### 选择要被脱壳的应用

![image-20240413023245107](./img/assets/image-20240413023245107.png)

### blackdex脱壳成功了 

> 开始抓包（分析三个变化参数 inf_enc明显是个hash串，token没有变化过）
>
> 分析笔记页面 多刷新几次 观察参数变化

![image-20240413021900737](./img/assets/image-20240413021900737.png)

![image-20240413021509860](./img/assets/image-20240413021509860.png)

### 找到笔记接口

![image-20240413021738545](./img/assets/image-20240413021738545.png)



### 找inf_enc参数

这是一个变化参数 因为同接口刷新几次以后发现-time，inf_enc变化

搜索inf_enc发现上文在拼接一个stringbuilder函数



![image-20240413022148332](./img/assets/image-20240413022148332.png)



### inf_enc rpc的hook点

![image-20240413022500050](./img/assets/image-20240413022500050.png)



### inf_enc只是一个md5码而已

![image-20240413022609837](./img/assets/image-20240413022609837.png)



### 以后深入探讨学习一下blackdex的源代码

![image-20240413023708412](./img/assets/image-20240413023708412.png)

```
深入探讨文章地址

https://blog.niunaijun.top/index.php/tag/BlackDex/
```



# 2. classloader探讨

职责：类加载器的职责是寻找和加载类



## 类加载器的种类

![image-20240413030314356](./img/assets/image-20240413030314356.png)

根据用途划分

- 系统加载器
  -  C++写的
  - 支撑虚拟机运行
  - 无法被java引用

- 扩展类加载器
  - 加载标准类库ext部分

- 应用程序加载器 
  - inmemorydexclassloader 内存捞dex文件
  - pathclassloader 
  - dexclassloader
- 用户自定义加载器



双亲委派

- 从下面往上找 截止顶部结束

- 从上向下加载到底部或者加载成功结束，否则classnotfound error



目的

- 执行一次

- 避免核心类库被替换







## 类加载器的层次结构

![image-20240413030212619](./img/assets/image-20240413030212619.png)



### 高评率使用的加载器（gpt答案）

![image-20240413031416514](./img/assets/image-20240413031416514.png)

### 通义千问答案

![image-20240413031531061](./img/assets/image-20240413031531061.png)



简单说 不同加载其有不同职责,职责若干 加载器若干!





## 开发者角度

引导类加载器（BootClassLoader C++），扩展加载器，应用程序加载器（统称 原生的系统类加载器）

> 主要还是因为了解不够的情况下 分不太清

用户类自定义类加载器





## jdk下 系统类加载器



<img src="./img/assets/image-20240413213410760.png" alt="image-20240413213410760" style="zoom:50%;" />



注意：类加载器的层次关系不代表是类加载器的继承关系 如下图



![image-20240413214140740](./img/assets/image-20240413214140740.png)

第一层

classloader 抽象 定义

secure classloader 继承+安全权限 定义

urlclassloader 通过url路径从jar文件和文件夹加载类和资源



![image-20240413214351359](./img/assets/image-20240413214351359.png)



## art角度下的classloader

注意：

开发代码上区别不大，但是jdk下的类加载与art下类加载并不同

![image-20240413220050254](./img/assets/image-20240413220050254.png)

art，jdk都是虚拟机 并遵守了jvm设计上的一些规范 art完全兼容支持 jvm 这也是java可以在sdk环境运行的主要原因



### art下开发者角度

- 系统类加载器
- 用户自定义类加载器

都是引导类加载器 解释如下

<img src="./img/assets/image-20240413220358837.png" alt="image-20240413220358837" style="zoom:200%;" />





- 总结1 art中引导类加载类是java类 可以java代码引用 并且实现classloader抽象类
- 总结2 jdk中 bootstrap 加载jdk核心类库 c++实现 无java引用 也实现classloader抽象类
- classloader是顶层规范的抽象类 约束加载器继承者的行为

### 介绍art下的系统类加载器

注意：真实情况下的类加载器数不胜数

bootclassloader（核心类库），pathclassloader（扩展），dexclassloader（app程序）



**dexclassloader继承basedexclassloader**

可加载dex相关文件

![image-20240413221437587](./img/assets/image-20240413221437587.png)

**pathclassloader继承baseclassloader**

加载系统类和应用程序类

![image-20240413221822648](./img/assets/image-20240413221822648.png)

### MainActivity的每一次层classloader验证

![image-20240413223242849](./img/assets/image-20240413223242849.png)



### 运行结果显示dexpathclassloader->bootclassloader

![image-20240413223610846](./img/assets/image-20240413223610846.png)



### 继承关系



![image-20240413223855221](./img/assets/image-20240413223855221.png)



**加载类介绍**

![image-20240413224002224](./img/assets/image-20240413224002224.png)





### 引导类加载器如何被创建

zygote进程

main方法是zygoteinit的入口

调用zygoteinit的preload

zygote的preloadClasses（初始化时候预加载常用类）

罗列部分类名

![image-20240413224659739](./img/assets/image-20240413224659739.png)



结论就是预加载越多（通用） 后期app启动就会越快



![image-20240413224927045](./img/assets/image-20240413224927045.png)



结论

art下的BootClassLoader用于在zygote的初始化阶段创建 用于预加载类的加载





总结



![image-20240413225146903](./img/assets/image-20240413225146903.png)

## classloader案例（分析）

#### BootClassLoader （因为包名不可见 所以无法引用）



#### DexClassLoader

```java
        // 假设 dex 文件位于应用的 files 目录下，名为 "classes2.dex"
        File dexFile = new File("/data/local/tmp/classes.dex");

        try {
            // 使用 PathClassLoader 加载 dex 文件
//            PathClassLoader pathClassLoader = new PathClassLoader(dexFile.getAbsolutePath(), getClassLoader());

            // 使用 DexFile 来获取 dex 文件中的类
            DexFile dex = new DexFile(dexFile);
            Enumeration<String> entries = dex.entries();

            // 遍历 dex 文件中的类
            while (entries.hasMoreElements()) {
                String className = entries.nextElement();
                Log.d("dex-test", className);
                // 你可以在这里进行类的进一步操作，例如实例化或调用方法
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

```

#### PathClassLoader 

```java
                PathClassLoader pathClassLoader = new PathClassLoader("/data/local/tmp/classes.dex");


```



**输出**

![image-20240413230422908](./img/assets/image-20240413230422908.png)

#### InmemoryClassLoader



### 编译原理前奏知识补充



![image-20240414000805323](./img/assets/image-20240414000805323.png)

- 前端
  - 词法分析，语法分析，语义分析
- 优化器
  - 中间代码重写
- 后端
  - 中间代码向机器语言的翻译



（逆向分析）art虚拟机中只涉及优化器和后端





**编译模式迭代过程**（jit  just-in-time，aot ahead-of-time）

- jit
- 随后aot
- jit+aot



# 3. elf文件格式



so文件就是elf（理解elf最好的方式就是写一个解析工具解析一下so文件）

可用readelf工具解析elf

- readelf -h xxso 查看头部信息
- readelf -S xxxso 查看so section 头信息
- readelf -l xxxso 查看so得段头信息
- readelf -a xxxso 查看elf全部内容

```
elf头部定义得伪代码
#include <cstdint>

// ELF文件头部结构体
struct ElfHeader {
    uint8_t magic[4];                  // Magic Number
    uint8_t file_type;                 // 文件类型
    uint8_t machine_type;              // 机器类型
    uint8_t version;                   // 版本号
    uint64_t entry_point_addr;         // 入口地址
    uint64_t program_header_offset;    // 程序头表偏移
    uint64_t section_header_offset;    // 节头表偏移
    uint32_t flags;                    // 标志
    uint16_t header_size;              // 头部大小
    uint16_t program_header_entry_size;// 程序头表条目大小
    uint16_t num_program_headers;      // 程序头表条目数量
    uint16_t section_header_entry_size;// 节头表条目大小
    uint16_t num_section_headers;      // 节头表条目数量
    uint16_t string_table_index;       // 字符串表索引
};

// 定义ELF文件头部的魔术数字
const uint8_t ELF_MAGIC[4] = {0x7F, 'E', 'L', 'F'};

// 根据实际情况定义其他常量和结构体

```

头部信息解释

1. **Magic Number**: ELF文件的开始处包含一个特殊的魔术数字，用于标识文件的格式。在32位ELF文件中，这个数字是0x7F, 'E', 'L', 'F'的组合；在64位ELF文件中，这个数字是0x7F, 'E', 'L', 'F', '2'的组合。
2. **文件类型（File Type）**: 指示文件的类型，如可执行文件、目标文件、共享目标文件等。
3. **机器类型（Machine Type）**: 指示文件目标体系结构的类型，如x86、ARM、MIPS等。
4. **版本号（Version）**: 指示ELF格式的版本号。
5. **入口地址（Entry Point Address）**: 可执行文件的入口点地址，即程序开始执行的地址。
6. **程序头表偏移（Program Header Table Offset）**: 指示程序头表的偏移量，程序头表包含了有关可执行文件的段信息。
7. **节头表偏移（Section Header Table Offset）**: 指示节头表的偏移量，节头表包含了有关文件中各个节（sections）的信息。
8. **标志（Flags）**: 包含了一些标志位，用于指示一些特殊的属性，比如是否包含重定位信息等。
9. **头部大小（Header Size）**: 指示ELF头部的大小。
10. **程序头表条目大小（Program Header Table Entry Size）**: 指示每个程序头表条目的大小。
11. **程序头表条目数量（Number of Program Header Table Entries）**: 指示程序头表中的条目数量。
12. **节头表条目大小（Section Header Table Entry Size）**: 指示每个节头表条目的大小。
13. **节头表条目数量（Number of Section Header Table Entries）**: 指示节头表中的条目数量。
14. **字符串表索引（String Table Index）**: 指示节头表中字符串表的索引，用于存储字符串信息，比如节名等。





安卓打包

![image-20240418203537404](./img/assets/image-20240418203537404.png)











# 4.dex文件格式

![image-20240418203840701](./img/assets/image-20240418203840701.png)



## dex头部信息描述

![image-20240418204617614](./img/assets/image-20240418204617614.png)

- string_ids 索引所有字符串

- type_ids 储存所有类型（类类型，基本类型）

- proto_ids 函数原型

- fields_id 类变量



### classdef 数据结构

存放类信息，相比dex文件更复杂，因为有数据指向了data区

1. **class_idx**: 一个指向类型描述符列表（type_ids）的索引，指示类的类型。
2. **access_flags**: 类的访问标志，指示类的访问权限和特性，例如 `public`, `private`, `final` 等。
3. **superclass_idx**: 一个指向类型描述符列表（type_ids）的索引，指示父类的类型。
4. **interfaces_off**: 指向接口列表的偏移量，列出了该类实现的所有接口。
5. **source_file_idx**: 指向源文件名的索引，指示该类的源文件名（如果有的话）。
6. **annotations_off**: 指向注解列表的偏移量，列出了与该类关联的所有注解。
7. **class_data_off**: 指向类数据项的偏移量，其中包含了该类的字段和方法的详细信息。
8. **static_values_off**: 指向静态变量值列表的偏移量，列出了该类的所有静态变量的初始值。



### codeitem 定义

- `registers_size`: 该方法使用的寄存器数量。
- `ins_size`: 方法的输入参数数量。
- `outs_size`: 方法的输出参数数量。
- `tries_size`: 异常处理器列表的大小。
- `debug_info_off`: 调试信息的偏移量，指向方法的调试信息。
- `insns_size`: 方法的指令数量。
- `insns`: 方法的指令数组，包含方法的所有指令。





















# 5.blackdex原理

总结：

虚拟化技术让app进程运行，加固壳自解密

前置原理

- 安卓虚拟化技术
- dex加载原理
- dexfile结构
- 安卓hook



基于blackbox开发的

简单说在blackdex app中安装一个安卓系统，在这个安卓系统中安装需要脱壳的app，然后基于dexfile结构体和加载原理脱壳进行代码还原

![image-20240418014600430](./img/assets/image-20240418014600430.png)



dex加载进内存

application通过loadedapk#makeapplication完成





# 6.fart脱壳 -理解hanbing大佬系列文章

## fart系列1  拨云见日

- 在合适的时机（明文阶段）获取dex起点和尺寸
- 两个脱壳点 dexfileparser（解析dex文件函数被调用得地方，明文才能解析否则就是加密），openmemory参数包含dex开始位置和大小（解密后也会以明文字节流刷入内存）
- fart的脱壳核心就是解密dex的起点和尺寸

![image-20240419115241799](./img/assets/image-20240419115241799.png)

- java中脱壳，可以通过类关联到其所在的dex，class->classloader->getDex->getbytes 
  - 类关联到classloader
  - classloader关联到dex对象
  - dex对象中字节流就是dex明文

### art下关键字快速定位

- 围绕dexfie结构体在海量得c++安卓代码中找到脱壳点

  - 直接查找搜dexfile 在 http://androidxref.com/8.0.0_r4/search?q=dexfile&project=dalvik
  - 间接查找 能够间接获取art得dexfile，如artMethod得到dexfile

  彩蛋部分提供的脱壳原理基于Android ART（Android RunTime）环境的特定运行机制，特别是其对DEX（Dalvik Executable）文件的处理方式。以下是彩蛋部分脱壳原理的详细解读：

**1. ART编译机制与脱壳**

**dex2oat**： ART在安装应用程序时，使用`dex2oat`工具将APK中的DEX文件编译成OAT（Optimized Android Runtime）格式。OAT文件包含了经过优化的机器码，可以直接在目标设备上高效执行。这个编译过程通常发生在系统安装应用时，或者在应用首次启动时（即时编译，JIT）。

**编译粒度**： `dex2oat`编译过程是按函数粒度进行的，即逐个编译DEX文件中的各个方法。这一点对于脱壳至关重要，因为并非所有方法都会被编译成OAT，尤其是类的初始化函数（`<clinit>`）。这些未编译的方法会在运行时由ART解释器动态执行。

**脱壳机会**： 由于某些壳可能通过干扰`dex2oat`的编译过程，使得原本应被编译的方法也被迫在解释器模式下运行。这就为脱壳提供了机会，即在解释器执行流程中找到合适的位置，动态提取出原始DEX文件。

![image-20240419133806776](./img/assets/image-20240419133806776.png)

##  fart系列2 FART正餐前甜点

![整体流程](https://img-blog.csdn.net/20170823105450922?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemh1OTI5MDMzMjYy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

Android ART环境中的一种通用、简单且高效的内存中DEX脱壳方法。这种方法利用了ART类加载执行流程中的关键类`ArtMethod`及其相关函数，通过Hook技术（如Xposed或Frida）实现对加固应用的脱壳。以下是该方法的概述和实现细节：

1. **ART类加载执行流程与ArtMethod类**

   在ART环境下，函数执行的关键在于`ArtMethod`类。在类加载过程中，ART会经历`LoadClass`->`LoadClassMembers`->`LinkCode`的步骤。`LoadClassMembers`函数负责准备类初始化和函数调用所需的变量和函数。具体包括遍历DEX文件中的字段（field）并初始化为`ArtField`对象，以及遍历类中的所有函数并初始化为`ArtMethod`对象。

2. **脱壳点：LoadClassMembers函数**

   `LoadClassMembers`函数是一个重要的脱壳点。它接收一个`const DexFile& dex_file`参数，该参数引用了当前处理的DEX文件。通过这个引用，可以定位到DEX文件在内存中的起始地址，从而实现脱壳。此外，函数内部对类中每个函数进行遍历并初始化`ArtMethod`对象的`LoadMethod`调用也是一个脱壳点。

3. **LoadMethod函数**

   `LoadMethod`函数负责初始化`ArtMethod`对象的相关属性，如方法索引（method_idx）、声明类、CodeItem偏移量、已解析方法和类型缓存等。其中，`dst->SetCodeItemOffset(it.GetMethodCodeItemOffset());`这一行尤为重要，它设置了当前函数所指向的内存中Smali指令的地址。这对于识别和处理不同类型的壳（如占坑型和重构型）至关重要。

4. **LinkCode函数**

   `LinkCode`函数进一步处理`ArtMethod`对象，设置其入口点（entry point）。对于非抽象方法，会安装来自OAT文件的invoke stub，并可能设置快速编译代码的入口点。对于抽象方法或需要进入解释器执行的方法，则设置相应的解释器桥接入口点。静态方法（非构造函数）会安装跳板（trampoline），在类初始化完成后会被替换为适当的入口点。

综上所述，这种脱壳方法的实现步骤大致如下：

- **Hook LoadClassMembers或LoadMethod函数**：通过Xposed或Frida等框架，在上述函数被调用时注入代码。
- **利用Hook点获取DEX文件信息**：在注入代码中，利用`LoadClassMembers`或`LoadMethod`函数的参数`const DexFile& dex_file`，获取DEX文件在内存中的起始地址和相关数据结构。
- **定位并dump内存中的DEX数据**：根据获取的DEX文件起始地址，将DEX文件内容从内存中复制出来，保存为独立的DEX文件。
- **处理特殊情况**：对于某些壳可能采用的占坑型或重构型策略，可根据`LoadMethod`中设置的`CodeItemOffset`等属性，识别并处理函数体的真实位置。
- **后续处理**：对于静态方法，可能需要等待`ClassLinker::FixupStaticTrampolines`完成后再进行适当的处理。

通过这种方法，可以简洁高效地实现在ART环境下对加固应用的脱壳，无需复杂的系统知识和大量反射操作，且具有较好的通用性。

##  fart系列3 FART：ART环境下基于主动调用的自动化脱壳方案 

### app启动流程

![image-20240419150239679](./img/assets/image-20240419150239679.png)

1. **`ActivityThread.main()`**：
   - 作为App进程的入口点，方法开始时进行一些初始化工作，如开启性能追踪、关闭`CloseGuard`（默认开启的内存泄漏检测机制，这里关闭以减少日志输出）、初始化用户环境、设置事件日志记录器、安装`AndroidKeyStoreProvider`、配置`TrustedCertificateStore`等。
   - 设置进程参数、准备主`Looper`（消息循环）。
   - 创建`ActivityThread`实例并调用`attach(false)`方法进行进一步初始化。
   - 将`ActivityThread`实例保存到静态变量`sMainThreadHandler`中以便全局访问。
   - 如果处于调试模式，可能会启用额外的日志打印。
   - 结束`ActivityThreadMain`事件追踪，进入主`Looper`的消息循环。
2. **`thread.attach(false)`**：
   - 这一步骤涉及一系列与系统交互的初始化工作，如注册到系统服务、设置线程池、创建`Binder`通信通道等，为后续接收系统消息和处理组件生命周期事件做准备。
3. **`handleBindApplication(AppBindData data)`**：
   - 当系统向App进程发送`bindApplication`请求时，`ActivityThread`通过`handleBindApplication`方法进行处理。
   - **步骤1**：创建`LoadedApk`对象，封装应用的包信息、类加载器等。
   - **步骤2**：基于`LoadedApk`创建应用上下文`ContextImpl`。
   - **步骤3**：创建`Instrumentation`对象，用于监控和控制应用组件的生命周期。
   - **步骤4**：通过`makeApplication`方法创建`Application`对象，并调用其`attachBaseContext`方法，将创建的`ContextImpl`传递给`Application`。此时`Application`与应用上下文关联。
   - **步骤5**：安装内容提供者（Content Providers）。
   - **步骤6**：调用`mInstrumentation.callApplicationOnCreate(app)`，触发`Application`的`onCreate`方法。

总结起来，Android App启动流程中：

- `ActivityThread.main()`是App进程的入口，负责启动主消息循环和初始化关键组件。
- `handleBindApplication`方法在接收到系统`bindApplication`请求时被调用，完成应用的真正启动过程。
- 在这一过程中，首先创建`LoadedApk`、`ContextImpl`和`Instrumentation`对象，然后创建并初始化`Application`对象。
- `Application`的`attachBaseContext`和`onCreate`方法是App代码执行的最早入口，它们分别负责与应用上下文关联和执行全局初始化逻辑。这也是加固工具常选择在此处进行干预（如代码脱壳、安全检查、权限控制等）的原因。

### 加壳原理 运行流程

![image-20240419150546839](./img/assets/image-20240419150546839.png)

**加壳原理与运行流程：**

1. **加壳入口**：
   - 加壳技术利用`Application`类的`attachBaseContext`和`onCreate`方法作为切入点，因为它们是App启动时最先获得执行权限的函数。在这些方法中，壳程序执行加密DEX文件的解密操作。
2. **加载解密后的DEX**：
   - 解密完成后，壳使用自定义的`ClassLoader`在内存中加载解密后的DEX文件。这种自定义`ClassLoader`通常绕过标准的类加载机制，直接加载内存中的DEX数据，避免在磁盘上留下未加密的痕迹。
3. **修复类加载环境**：
   - 为了使应用能够正常加载并调用解密后的DEX中的类和方法，壳通过Java反射技术修复关键变量，特别是`ClassLoader`。如果不修正`ClassLoader`，双亲委派机制会导致系统无法找到解密DEX中的类，引发`ClassNotFoundException`，导致应用崩溃。
4. **获取解密DEX**：
   - 一旦壳通过反射设置好了正确的`ClassLoader`，攻击者可以通过一系列反射操作获取到当前应用所加载的解密后的内存中DEX文件，实现对加密内容的提取。

**对抗与反制：**

1. **指令抽取型壳**：
   - 针对整体加密的DEX容易被内存Dump并还原原始DEX的问题，加固厂商发展出指令抽取型壳技术。这种壳只在函数执行前才解密对应方法的指令区域，使得即使Dump内存中的DEX，也无法获取到关键方法的原始指令，增加了脱壳难度。
2. **FUPK3工具**：
   - 作为应对指令抽取型壳的脱壳工具，FUPK3采用欺骗策略。它主动调用DEX中的各个函数，触发壳在方法执行前的解密操作，从而暴露解密后的指令区域。通过这种方法，FUPK3能够完成对指令抽取型壳的脱壳，提取出原本加密的方法体。



整体壳dump+主动调用 upx3欺骗调用







### 脱壳总结

1. dexfile结构体完整dump
2. 主动调用每一个方法，实现对codeitem得dump
3. 通过主动dump下来的codeitem对dex被抽取方法进行修复





### dumpDexfile

APP中的Application类中的attachBaseContext和onCreate函数是app中最先执行的方法。壳都是通过替换APP的Application类并自己实现这两个函数，并在这两个函数中实现dex的解密加载，hook系统中Class和method加载执行流程中的关键函数，最后通过反射完成关键变量如最终的Classloader，Application等的替换从而完成执行权的交付。、



dumpMethodCode

activityThread中的performLaunchActivity 函数作为时机，获取最终classloader，还有一个好处该函数与最终的application都在activityThread类中

![image-20240419162210253](./img/assets/image-20240419162210253.png)

通过classloader得到mcookie （so层dexfile的句柄） 在framework添加两个函数提供调用 dumpDexFile，dumpMethodCode

- dumpDexFile     保存dex文件
- dumpMethodCode   保存codeitem

调用art的invoke完成方法的主动调用

在invoke中判断 如果是我们自己的调用 使用dump 然后返回从而完成对壳的欺骗



对java层传来的method结构体进行类型转换，转成native的ArtMethod对象，接下来调用artMethod的myfartinvoke实现，并完成方法体的dump，

artMethod的invoke我们在第一个参数Thread传递null标志作为主动调用的标识，





### 抽取类函数的修复

壳在完成对内存中加载的dex的解密后，该dex的索引区即stringid，typeid,methodid,classdef和对应的data区中的string列表并未加密。而对于classdef中类函数的CodeItem部分可能被加密存储或者直接指向内存中另一块区域。这里我们只需要使用dump下来的method的CodeItem来解析对应的被抽取的方法即可，这里我提供了一个用python实现的修复脚本。