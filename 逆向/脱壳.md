# 逆向日记系列



# 1.脱壳实战（工具篇） 

简述

通用脱壳工具好使，遇到反脱壳的检测手段稍微上点难度就jj了。

聊这么多基础原理，都是为了降维打击和多一些逆向思路。

比如fart ，cookie脱壳（此处 cookie为art内部术语，不是web cookie）

## 找包packagae

> dumpsys window windows | grep mCurrentFocus

```txt
adb shell dumpsys window windows | grep mCurrentFocus

mCurrentFocus=Window{e415d0f u0 com.chaoxing.mobile/com.chaoxing.mobile.main.ui.MainTabActivity}
```



<img src="./img/image-20240413005807391.png" alt="image-20240413005807391" style="zoom:80%;" />





## frida-dexdump脱壳



```
核心原理：暴力搜索
git地址：https://github.com/hluwa/frida-dexdump?tab=readme-ov-file
公众号地址：https://mp.weixin.qq.com/s/n2XHGhshTmvt2FhxyFfoMA

frida-dexdump -U -n com.chaoxing.mobile -o ./xuexitong -d --sleep 5

-o 输出目录
-d 深度搜索
--sleep 等待？s开始脱壳

结果：扫描出来一堆没用的dex文件
```

### -n运行

![image-20240413015032525](./img/image-20240413015032525.png)



```
显示all done说明结束

然后整体编译刚脱壳出来的文件
jadx -d <输出目录路径> *.dex
jadx -d output *.dex

如果hook时间不合适 如下图
```



![image-20240413015833031](./img/image-20240413015833031.png)



### -f运行

![image-20240413015926153](./img/image-20240413015926153.png)



### 反编译失败

![image-20240413020804232](./img/image-20240413020804232.png)



## blackdex   32位，64位apk脱壳

blackdex地址 https://github.com/CodingGay/BlackDex/releases 



![image-20240413023142902](./img/image-20240413023142902.png)

#### 选择要被脱壳的应用

![image-20240413023245107](./img/image-20240413023245107.png)

### blackdex脱壳成功了 

> 开始抓包（分析三个变化参数 inf_enc明显是个hash串，token没有变化过）
>
> 分析笔记页面 多刷新几次 观察参数变化

![image-20240413021900737](./img/image-20240413021900737.png)

![image-20240413021509860](./img/image-20240413021509860.png)

### 找到笔记接口

![image-20240413021738545](./img/image-20240413021738545.png)



### 找inf_enc参数

这是一个变化参数 因为同接口刷新几次以后发现-time，inf_enc变化

搜索inf_enc发现上文在拼接一个stringbuilder函数



![image-20240413022148332](./img/image-20240413022148332.png)



### inf_enc rpc的hook点

![image-20240413022500050](./img/image-20240413022500050.png)



### inf_enc只是一个md5码而已

![image-20240413022609837](./img/image-20240413022609837.png)



### 以后深入探讨学习一下blackdex的源代码

![image-20240413023708412](./img/image-20240413023708412.png)

```
深入探讨文章地址

https://blog.niunaijun.top/index.php/tag/BlackDex/
```



# 2. classloader探讨

职责：类加载器的职责是寻找和加载类



## 类加载器的种类

![image-20240413030314356](./img/image-20240413030314356.png)

根据用途划分

- 系统加载器
  -  C++写的
  - 支撑虚拟机运行
  - 无法被java引用

- 扩展类加载器
  - 加载标准类库ext部分

- 应用程序加载器 
  - inmemorydexclassloader 内存捞dex文件
  - pathclassloader 
  - dexclassloader
- 用户自定义加载器



双亲委派

- 从下面往上找 截止顶部结束

- 从上向下加载到底部或者加载成功结束，否则classnotfound error



目的

- 执行一次

- 避免核心类库被替换







## 类加载器的层次结构

![image-20240413030212619](./img/image-20240413030212619.png)



### 高评率使用的加载器（gpt答案）

![image-20240413031416514](./img/image-20240413031416514.png)

### 通义千问答案

![image-20240413031531061](./img/image-20240413031531061.png)



简单说 不同加载其有不同职责,职责若干 加载器若干!





## 开发者角度

引导类加载器（BootClassLoader C++），扩展加载器，应用程序加载器（统称 原生的系统类加载器）

> 主要还是因为了解不够的情况下 分不太清

用户类自定义类加载器





## jdk下 系统类加载器



<img src="./img/image-20240413213410760.png" alt="image-20240413213410760" style="zoom:50%;" />



注意：类加载器的层次关系不代表是类加载器的继承关系 如下图



![image-20240413214140740](./img/image-20240413214140740.png)

第一层

classloader 抽象 定义

secure classloader 继承+安全权限 定义

urlclassloader 通过url路径从jar文件和文件夹加载类和资源



![image-20240413214351359](./img/image-20240413214351359.png)



## art角度下的classloader

注意：

开发代码上区别不大，但是jdk下的类加载与art下类加载并不同

![image-20240413220050254](./img/image-20240413220050254.png)

art，jdk都是虚拟机 并遵守了jvm设计上的一些规范 art完全兼容支持 jvm 这也是java可以在sdk环境运行的主要原因



### art下开发者角度

- 系统类加载器
- 用户自定义类加载器

都是引导类加载器 解释如下

<img src="./img/image-20240413220358837.png" alt="image-20240413220358837" style="zoom:200%;" />





- 总结1 art中引导类加载类是java类 可以java代码引用 并且实现classloader抽象类
- 总结2 jdk中 bootstrap 加载jdk核心类库 c++实现 无java引用 也实现classloader抽象类
- classloader是顶层规范的抽象类 约束加载器继承者的行为

### 介绍art下的系统类加载器

注意：真实情况下的类加载器数不胜数

bootclassloader（核心类库），pathclassloader（扩展），dexclassloader（app程序）



**dexclassloader继承basedexclassloader**

可加载dex相关文件

![image-20240413221437587](./img/image-20240413221437587.png)

**pathclassloader继承baseclassloader**

加载系统类和应用程序类

![image-20240413221822648](./img/image-20240413221822648.png)

### MainActivity的每一次层classloader验证

![image-20240413223242849](./img/image-20240413223242849.png)



### 运行结果显示dexpathclassloader->bootclassloader

![image-20240413223610846](./img/image-20240413223610846.png)



### 继承关系



![image-20240413223855221](./img/image-20240413223855221.png)



**加载类介绍**

![image-20240413224002224](./img/image-20240413224002224.png)





### 引导类加载器如何被创建

zygote进程

main方法是zygoteinit的入口

调用zygoteinit的preload

zygote的preloadClasses（初始化时候预加载常用类）

罗列部分类名

![image-20240413224659739](./img/image-20240413224659739.png)



结论就是预加载越多（通用） 后期app启动就会越快



![image-20240413224927045](./img/image-20240413224927045.png)



结论

art下的BootClassLoader用于在zygote的初始化阶段创建 用于预加载类的加载





总结



![image-20240413225146903](./img/image-20240413225146903.png)

## classloader案例（分析）

#### BootClassLoader （因为包名不可见 所以无法引用）



#### DexClassLoader

```java
        // 假设 dex 文件位于应用的 files 目录下，名为 "classes2.dex"
        File dexFile = new File("/data/local/tmp/classes.dex");

        try {
            // 使用 PathClassLoader 加载 dex 文件
//            PathClassLoader pathClassLoader = new PathClassLoader(dexFile.getAbsolutePath(), getClassLoader());

            // 使用 DexFile 来获取 dex 文件中的类
            DexFile dex = new DexFile(dexFile);
            Enumeration<String> entries = dex.entries();

            // 遍历 dex 文件中的类
            while (entries.hasMoreElements()) {
                String className = entries.nextElement();
                Log.d("dex-test", className);
                // 你可以在这里进行类的进一步操作，例如实例化或调用方法
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

```

#### PathClassLoader 

```java
                PathClassLoader pathClassLoader = new PathClassLoader("/data/local/tmp/classes.dex");


```



**输出**

![image-20240413230422908](./img/image-20240413230422908.png)

#### InmemoryClassLoader



### 编译原理前奏知识补充



![image-20240414000805323](./img/image-20240414000805323.png)

- 前端
  - 词法分析，语法分析，语义分析
- 优化器
  - 中间代码重写
- 后端
  - 中间代码向机器语言的翻译



（逆向分析）art虚拟机中只涉及优化器和后端





**编译模式迭代过程**（jit  just-in-time，aot ahead-of-time）

- jit
- 随后aot
- jit+aot



# 3. elf文件格式



so文件就是elf（理解elf最好的方式就是写一个解析工具解析一下so文件）

可用readelf工具解析elf

- readelf -h xxso 查看头部信息
- readelf -S xxxso 查看so section 头信息
- readelf -l xxxso 查看so得段头信息
- readelf -a xxxso 查看elf全部内容

```
elf头部定义得伪代码
#include <cstdint>

// ELF文件头部结构体
struct ElfHeader {
    uint8_t magic[4];                  // Magic Number
    uint8_t file_type;                 // 文件类型
    uint8_t machine_type;              // 机器类型
    uint8_t version;                   // 版本号
    uint64_t entry_point_addr;         // 入口地址
    uint64_t program_header_offset;    // 程序头表偏移
    uint64_t section_header_offset;    // 节头表偏移
    uint32_t flags;                    // 标志
    uint16_t header_size;              // 头部大小
    uint16_t program_header_entry_size;// 程序头表条目大小
    uint16_t num_program_headers;      // 程序头表条目数量
    uint16_t section_header_entry_size;// 节头表条目大小
    uint16_t num_section_headers;      // 节头表条目数量
    uint16_t string_table_index;       // 字符串表索引
};

// 定义ELF文件头部的魔术数字
const uint8_t ELF_MAGIC[4] = {0x7F, 'E', 'L', 'F'};

// 根据实际情况定义其他常量和结构体

```

头部信息解释

1. **Magic Number**: ELF文件的开始处包含一个特殊的魔术数字，用于标识文件的格式。在32位ELF文件中，这个数字是0x7F, 'E', 'L', 'F'的组合；在64位ELF文件中，这个数字是0x7F, 'E', 'L', 'F', '2'的组合。
2. **文件类型（File Type）**: 指示文件的类型，如可执行文件、目标文件、共享目标文件等。
3. **机器类型（Machine Type）**: 指示文件目标体系结构的类型，如x86、ARM、MIPS等。
4. **版本号（Version）**: 指示ELF格式的版本号。
5. **入口地址（Entry Point Address）**: 可执行文件的入口点地址，即程序开始执行的地址。
6. **程序头表偏移（Program Header Table Offset）**: 指示程序头表的偏移量，程序头表包含了有关可执行文件的段信息。
7. **节头表偏移（Section Header Table Offset）**: 指示节头表的偏移量，节头表包含了有关文件中各个节（sections）的信息。
8. **标志（Flags）**: 包含了一些标志位，用于指示一些特殊的属性，比如是否包含重定位信息等。
9. **头部大小（Header Size）**: 指示ELF头部的大小。
10. **程序头表条目大小（Program Header Table Entry Size）**: 指示每个程序头表条目的大小。
11. **程序头表条目数量（Number of Program Header Table Entries）**: 指示程序头表中的条目数量。
12. **节头表条目大小（Section Header Table Entry Size）**: 指示每个节头表条目的大小。
13. **节头表条目数量（Number of Section Header Table Entries）**: 指示节头表中的条目数量。
14. **字符串表索引（String Table Index）**: 指示节头表中字符串表的索引，用于存储字符串信息，比如节名等。





安卓打包

![image-20240418203537404](./img/image-20240418203537404.png)











# 4.dex文件格式

![image-20240418203840701](./img/image-20240418203840701.png)



## dex头部信息描述

![image-20240418204617614](./img/image-20240418204617614.png)

- string_ids 索引所有字符串

- type_ids 储存所有类型（类类型，基本类型）

- proto_ids 函数原型

- fields_id 类变量



### classdef 数据结构

存放类信息，相比dex文件更复杂，因为有数据指向了data区

1. **class_idx**: 一个指向类型描述符列表（type_ids）的索引，指示类的类型。
2. **access_flags**: 类的访问标志，指示类的访问权限和特性，例如 `public`, `private`, `final` 等。
3. **superclass_idx**: 一个指向类型描述符列表（type_ids）的索引，指示父类的类型。
4. **interfaces_off**: 指向接口列表的偏移量，列出了该类实现的所有接口。
5. **source_file_idx**: 指向源文件名的索引，指示该类的源文件名（如果有的话）。
6. **annotations_off**: 指向注解列表的偏移量，列出了与该类关联的所有注解。
7. **class_data_off**: 指向类数据项的偏移量，其中包含了该类的字段和方法的详细信息。
8. **static_values_off**: 指向静态变量值列表的偏移量，列出了该类的所有静态变量的初始值。



### codeitem 定义

- `registers_size`: 该方法使用的寄存器数量。
- `ins_size`: 方法的输入参数数量。
- `outs_size`: 方法的输出参数数量。
- `tries_size`: 异常处理器列表的大小。
- `debug_info_off`: 调试信息的偏移量，指向方法的调试信息。
- `insns_size`: 方法的指令数量。
- `insns`: 方法的指令数组，包含方法的所有指令。





















# blackdex原理

总结：

虚拟化技术让app进程运行，加固壳自解密

前置原理

- 安卓虚拟化技术
- dex加载原理
- dexfile结构
- 安卓hook



基于blackbox开发的

简单说在blackdex app中安装一个安卓系统，在这个安卓系统中安装需要脱壳的app，然后基于dexfile结构体和加载原理脱壳进行代码还原

![image-20240418014600430](./img/image-20240418014600430.png)



dex加载进内存

application通过loadedapk#makeapplication完成







  
















# autojs



又有人开始维护了

autojsx 地址

https://github.com/kkevsekk1/AutoX



# cdp